package com.kh.chap03_override.run;

import com.kh.chap03_override.model.vo.Book;

public class OverrideRun {

	public static void main(String[] args) {
		Book bk1 = new Book("수학의 정석", "나수학", 100);
		Book bk2 = new Book("칭찬은 고래도 춤추게 한다.", "고래", 200);
		
		// 객체 -> 박스안에 주소값이 있는 것
		// .toString은 객체여야만 붙는다.
		System.out.println(bk1.toString());
		System.out.println(bk2);
		
		// 출력문에 레퍼런스(주소값을 가지고 있는 객체)를 출력하고자 할 때 JVM이 자동으로 해당 레퍼런스객체.toString() 메소드 호출
		
		// 오버라이딩 전 : object 클래스의 toString()라고 하는 메소드가 호출 => 풀클래스명 + @ + 객체의 16진수 주소값 리턴
		// 오버라이딩 후 : book 클래스의 toString() 실행 => 해당 객체가 가지고 있는 모든 필드값을 한 문자열로 합쳐 리턴

	}
	
	/*
	 * - 오버라이딩
	 * 1) 자식 클래스가 상속받고 있는 부모클래스이 메소드를 재정의(재작성) 하는 것
	 * 2) 부모가 재공하는 메소드를 자식이 일부 고쳐서 사용하겠다는 의미
	 * 3) 자식객체를 통해 실행시 자식 메소드가 우선권을 가짐
	 * 
	 * - 오버라이딩 성립 조건
	 * 1) 부모메소드명 동일
	 * 2) 매개변수 개수, 자료형, 순서 동일(매개변수명은 상관 없다.)
	 * 3) 부모메소드 반환형 동일하게 설정
	 * 4) 부모메소드의 접근제한자보다 범위가 같거나 커야 한다.
	 * ex) 부모메소드의 접근제한자 protected일 경우 자식 메소드의 접근제한자 protected, public
	 * => 규약의 개념이 들어가 있다.
	 * 
	 * @Ovrride 어노테이션
	 * - 생략가능(명시하지 않아도 오버라이딩 된 상태)
	 * 
	 * - 어노테이션 붙이는 이유
	 * 1) 부모메소드명이나 매개변수가 수정될 경우 = 알아보기 쉽다.(즉, 틀리면 알려줌)
	 * 2) 자식메소드 기술시 오타가 있을 경우 => 알아보기 쉽다.
	 * => 단지 이 메소드 오버라이딩한 메소드라고 알려주기 위함
	 * 
	 */

}
